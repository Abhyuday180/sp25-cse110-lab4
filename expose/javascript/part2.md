Question 1:

3 will be printed.

Question 2:

150 will be printed

Question 3:

150 will be printed

Question 4:

[50, 100, 150]
This is 50% of each original price as that is what the function does by 
multiplying by (1 - discount)

Question 5:

The code returns an error because let is block scoped and i is declared inside 
the for block.

Question 6:

The code returns an error because let is block scoped and discountedPrice is 
declared inside the for block.

Question 7:

150 is printed because finalPrice was declared in line 4 which means its scope 
is the entire function.

Question 8:

[50, 100, 150]
This is 50% of each original price as that is what the function does by 
multiplying by (1 - discount)

Question 9:

The code returns an error because let is block scoped and i is declared inside 
the for block.

Question 10:

3 is printed because that is the number of items or the length of prices

Question 11:

[50, 100, 150] because only the reference to the array is immutable, the 
contents aren't.

Question 12:
A:

student.name
B:

student["Grad Year"]
C:

student.greeting()
D:

student["Favourite Teacher"].name
E:

student.courseLoad[0]


Question 13:
A: 

"32", because one of the operands was a string.
B:

1, because - is always numeric.
C:

3, because null becomes 0 in numeric operations.
D:

"3null", because one of the operands was a string.
E:

4, because true becomes 1 in numeric operations.
F:

0, because null and false both become 0 in numeric operations.
G:

"3undefined", because one of the operands was a string.
H:

NaN, because undefined becomes NaN in numeric operations and 3-NaN=NaN.

Question 14:
A: 

true, because when comparing values of different types, JavaScript converts 
the values to numbers.
B:

false, since both are strings and '12' is lexicographically "smaller".
C:

true, because when comparing values of different types, JavaScript converts 
the values to numbers.
D:

false, === requires that the type also must be the same.
E:

false, true becomes 1 in numeric operations and 1 != 2.
F:

true, because Boolean converts 2 into true and true === true 
(same type and value)

Question 15:

== converts types when they aren't the same and is considered loose-equality.
=== requires the type to be the same and is considered strict-equality.
=== is safer.

Question 17:

[2, 4, 6] will be the result. This is because for every iteration, callback is
called on the number in the array and it is pushed to newArr.

Question 19:

1
4
3
2
will be printed, in this order.
